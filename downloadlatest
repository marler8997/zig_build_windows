#!/usr/bin/env python3
import os
import sys
import shutil
import subprocess
import json
import urllib.request

script_dir = os.path.dirname(os.path.abspath(__file__))

def run_output(*args, **kwargs):
    print("[RUN] " + subprocess.list2cmdline(*args))
    sys.stdout.flush()
    try:
        return subprocess.check_output(*args, **kwargs).decode('ascii')
    except subprocess.CalledProcessError:
        return ""
def run(*args, **kwargs):
    print("[RUN] " + subprocess.list2cmdline(*args))
    sys.stdout.flush()
    return subprocess.check_call(*args, **kwargs)

def prompt_int(msg, min, max):
    while True:
        sys.stdout.write("{} [{}-{}] ? ".format(msg, min, max))
        sys.stdout.flush()
        try:
            answer = int(sys.stdin.readline().strip())
        except ValueError:
            print("not an integer")
            continue
        if answer < min or answer > max:
            print("out of bounds")
            continue
        return answer

def find_prog(name):
    if os.name == "nt":
        results = run_output(["where", name]).splitlines()
        return None if len(results) == 0 else results[0]
    else:
        sys.exit("not implemented")

def curl_download(url, file):
    run(["curl", url, "--output", file])

def python_download(url, file):
    print("urllib downloading '{}'...".format(url))
    with urllib.request.urlopen(url) as request:
        with open(file, "wb") as filed:
            filed.write(request.read())

def determine_download_func():
    #download_conf_filename = os.path.join(script_dir, "download.conf")
    #if os.path.exists(download_conf_filename):
    #    with open(download_conf_filename, "r") as file:
    #        download_conf_json = json.load(file)
    #    download_method = download_conf_json["download_method"]

    # try curl first, it handles proxies and other things better than
    # the python library
    curl = find_prog("curl")
    if curl:
        return curl_download
    # todo: try wget?
    return python_download

cached_download_func = None
def get_download_func():
    global cached_download_func
    if not cached_download_func:
        cached_download_func = determine_download_func()
        if not cached_download_func:
            sys.exit("Error: failed to find a way to download files via HTTP")
    return cached_download_func

def download_no_check(url, file):
    file_tmp = file + ".downloading"
    if os.path.exists(file_tmp):
        os.remove(file_tmp)
    get_download_func()(url, file_tmp)
    if os.path.exists(file):
        os.remove(file)
    os.rename(file_tmp, file)

def download_if_needed(url, file):
    if os.path.exists(file):
        print("file '{}' already downloaded".format(file))
    else:
        download_no_check(url, file)

def fetch_download_json():
    url = "https://ziglang.org/download/index.json"
    filename = "zigdownload.json"
    download_no_check(url, filename)
    with open(filename, "r") as file:
        return json.load(file)
    #os.remove(filename)

def get_latest_zig_url(platform):
    download_json = fetch_download_json()
    return download_json["master"][platform]["tarball"]

if os.name == "nt":
    import zipfile

    def determine_batch_file():
        zig_batch_files = run_output(["where", "zig.bat"]).splitlines()
        if len(zig_batch_files) == 1:
            print("using '{}'".format(zig_batch_files[0]))
            return zig_batch_files[0]
        if len(zig_batch_files) > 1:
            print("found multiple zig batch files in PATH")
            print("--------------------------------------------------------------------------------")
            file_index = 0
            for file in zig_batch_files:
                print("[{}] {}".format(file_index, file))
                file_index += 1
            selected_index = prompt_int("Please select a batch file to update", 0, len(zig_batch_files) - 1)
            return zig_batch_files[selected_index]

        print("no zig batch file in PATH, select one of the following directories to install it:")
        print("--------------------------------------------------------------------------------")
        paths = os.environ["PATH"].split(';')
        path_index = 0
        for path in paths:
            print("[{}] '{}'".format(path_index, path))
            path_index += 1
        selected_index = prompt_int("Please select a path to install zig.bat", 0, len(paths) - 1)
        install_dir = paths[selected_index]
        print("will install zig.bat to '{}'".format(install_dir))
        return os.path.join(install_dir, "zig.bat")

    zig_batch_file = determine_batch_file()
    zig_batch_dir = os.path.dirname(zig_batch_file)
    url = get_latest_zig_url("x86_64-windows")

    #
    # Download and extract latest version of zig
    #
    archive_basename = os.path.basename(url)
    installed_basename = archive_basename[:-4]
    print("latest name is '{}'".format(installed_basename))
    install_dir = os.path.join(zig_batch_dir, installed_basename)
    if os.path.exists(install_dir):
        print("Latest version of zig already downloaded to '{}'".format(install_dir))
    else:
        archive_file = os.path.join(zig_batch_dir, archive_basename)
        download_if_needed(url, archive_file)

        install_dir_tmp = install_dir + ".extracting"
        if os.path.exists(install_dir_tmp):
            shutil.rmtree(install_dir_tmp)
        print("extracting '{}'...".format(archive_file))
        with zipfile.ZipFile(archive_file, 'r') as zip:
            zip.extractall(install_dir_tmp)
        os.rename(os.path.join(install_dir_tmp, installed_basename), install_dir)
        shutil.rmtree(install_dir_tmp)
        os.remove(archive_file)

    #
    # Update batch file to point to new version of zig
    #
    zig_exe = os.path.join(install_dir, "zig.exe")
    if not os.path.exists(zig_exe):
        sys.exit("Error: zig exe '{}' does not exist even after installing zig?".format(zig_exe))
    batch_file_contents = "@{} %*".format(zig_exe)

    update_batch_file = False
    if not os.path.exists(zig_batch_file):
        print("Creating batch file '{}' with these contents:".format(zig_batch_file))
        print(batch_file_contents)
        update_batch_file = True
    else:
        with open(zig_batch_file, "r") as file:
            current_contents = file.read()
        if current_contents == batch_file_contents:
            print("Batch file '{}' already correct:".format(zig_batch_file))
            print(batch_file_contents)
        else:
            print("-------------------------------------------------")
            print("TODO: prompt to remove old version of zig?")
            print("-------------------------------------------------")
            print("Updating batch file contents.  Current Content:")
            print(current_contents)
            print("New Content:")
            print(batch_file_contents)
            update_batch_file = True

    if update_batch_file:
        with open(zig_batch_file, "w") as file:
            file.write(batch_file_contents)

